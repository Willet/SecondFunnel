{% load staticfiles %}
{% load compress %}

{% compress js %}
<script type="text/javascript">
    var Willet = Willet || {},  // Willet namespace
        local_data = local_data || {};  // exists in mobile themes

    window.PAGES_INFO = {
        'base_url': '{{ base_url }}',  // might be absent in TEST_PAGE_DATA
        'page': {
            'pubDate': '{{ pub_date }}',  // for verifying the original upload date of a static campaign. for human use only
            'id': '{{ campaign.default_intentrank.id|default:campaign.id }}',
            'main-block-template': '{{ campaign.template }}',
            'SHUFFLE_RESULTS': {{ campaign.shuffle_results|default:'true' }},
            'stl-image': '{{ campaign.stl_image }}',
            'featured-image': '{{ campaign.featured_image }}',
            'description': '{{ campaign.description|escapejs }}',
            'offline': false,  // true only in TEST_PAGE_DATA
            'product': {{ product.json|safe }},
            'categories': [
            {% with categories=campaign.intentrank.all%}
            {% if categories|length > 1 %}
            {% for category in categories %}
                {
                    'id': '{{ category.id }}',
                    'name': '{{ category.name }}'
                }{% if not forloop.last %},{% endif %}
            {% endfor %}
            {% endif %}
            {% endwith %}
            ]
        },
        'store': {
            'id': '{{ campaign.store.slug }}',
            'name': '{{ campaign.store.name }}'
        },
        'content': [],
        'featured': {% include "pinpoint/snippets/product_object.js" with product=product featured=True only %}
        {% if backup_results %}{# offline, pseudo-custom results #}
        , 'backupResults': {{ backup_results|safe }}
        {% endif %}
    };

    // can't use user agents - desktop CSS gets triggered on high ppi devices,
    // messing up everything
    (Willet.browser=Willet.browser||{}).mobile=(document.width < 1024);
</script>
<script src="{% static "js/underscore.js" %}"></script>
<script src="{% static "js/jquery-1.8.1.min.js" %}"></script>
<script type="text/javascript">
    // only forget jquery mobile if not needed
    if (Willet.browser.mobile) {
        $(document).bind("mobileinit", function () {
            $.mobile.autoInitializePage = false;
        });
        $.getScript('{% static "js/jquery.mobile-1.2.1.min.js" %}');
    } else {
        $.mobile = {};
    }
</script>
<script src="{% static "js/jquery.tools.js" %}"></script>
<script src="{% static "pinpoint/js/mediator.js" %}"></script>
<script src="{% static "pinpoint/js/utils.js" %}"></script>
<script src="{% static "pinpoint/js/tracking.js" %}"></script>
<script src="{% static "pinpoint/js/button_maker.js" %}"></script>
<script src="{% static "pinpoint/js/pages.js" %}"></script>
<script src="{% static "pinpoint/js/pages.ir.js" %}"></script>
<script src="{% static "js/jquery.viewport.js" %}"></script>
<script src="{% static "js/jquery.masonry.min.js" %}"></script>
<script src="{% static "js/jquery.imagesloaded.min.js" %}"></script>
<script src="{% static "js/mbp.js" %}"></script>
<script src="{% static "js/swipe.js" %}"></script>

<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '{{ ga_account_number }}']);

    _gaq.push(['_setCustomVar',
        1,                          // slot id
        'StoreID',                  // name
        '{{ campaign.store.id }}',  // value
        3                           // scope: page-level
    ]);

    _gaq.push(['_setCustomVar',
        2,
        'CampaignID',
        '{{ campaign.default_intentrank.id|default:campaign.id }}',
        3
    ]);

    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();


    if (Willet.browser.mobile) {
        $(function () {
            $.mobile.initializePage();
            PAGES.init();
            $.mobile.hidePageLoadingMsg();
        });
    } else {
        $(function() {
            $.Mason.prototype._placeBrick = function( brick ) {
                var $brick = $(brick),
                        colSpan, groupCount, groupY, groupColY, j,
                        dupes, instagramImg;

                // START WILLET
                this.recent = this.recent || [];

                // Check to see if we've recently included this instagram
                // image. If so, skip it.
                if ($brick.hasClass('instagram')) {
                    instagramImg = $brick.find('img').not('.social-buttons ' +
                            'img').prop('src');
                    dupes = _.filter(this.recent, function($elem) {
                        var elemImg = $elem.find('img').not('.social-buttons ' +
                                'img').prop('src');
                        return (elemImg == instagramImg);
                    });

                    if (dupes.length != 0) {
                        this.remove($brick);
                        return;
                    }
                }

                while(this.recent.length > 5) {
                    this.recent.shift();
                }
                this.recent.push($brick);
                // END WILLET

                //how many columns does this brick span
                colSpan = Math.ceil( $brick.outerWidth(true) / this.columnWidth );
                colSpan = Math.min( colSpan, this.cols );

                if ( colSpan === 1 ) {
                    // if brick spans only one column, just like singleMode
                    groupY = this.colYs;
                } else {
                    // brick spans more than one column
                    // how many different places could this brick fit horizontally
                    groupCount = this.cols + 1 - colSpan;
                    groupY = [];

                    // for each group potential horizontal position
                    for ( j=0; j < groupCount; j++ ) {
                        // make an array of colY values for that one group
                        groupColY = this.colYs.slice( j, j+colSpan );
                        // and get the max value of the array
                        groupY[j] = Math.max.apply( Math, groupColY );
                    }

                }

                // BEGIN WILLET
                /*
                 *   We need to ensure that the short column is NOT an odd numbered
                 *   column, so, we may need to find the second shortest column
                 * */
                // get the minimum Y value from the columns
                var dupeGroupY = groupY.slice(0);
                var minYObjs = []
                for (var k=0; k < dupeGroupY.length; k++) {
                    minYObjs.push({
                        'column': k,
                        'value': dupeGroupY[k]
                    });
                }

                minYObjs.sort(function(a,b) {
                    if (a.value !== b.value) {
                        return a.value - b.value;
                    } else {
                        return a.column - b.column;
                    }
                });

                var minimumY = Math.min.apply( Math, groupY ),
                        shortCol = 0;

                // Iterate over all the minimums...
                for (var l= 0, len = minYObjs.length; l < len; l++) {
                    var item = minYObjs[l];
                    shortCol = item.column;
                    minimumY = item.value;

                    if ($brick.hasClass('youtube') && (shortCol % 2 != 0)) {
                        continue;
                    } else {
                        break;
                    }
                }

                // END WILLET

                // position the brick
                var position = {
                    top: minimumY + this.offset.y
                };

                // position.left or position.right
                position[ this.horizontalDirection ] = this.columnWidth * shortCol + this.offset.x;
                this.styleQueue.push({ $el: $brick, style: position });

                // apply setHeight to necessary columns
                var setHeight = minimumY + $brick.outerHeight(true),
                        setSpan = this.cols + 1 - len;
                for ( i=0; i < setSpan; i++ ) {
                    this.colYs[ shortCol + i ] = setHeight;
                }
            };
        });

        function onYouTubeIframeAPIReady() {
            if (!Willet.browser.mobile) {
                PAGES.init();
            }
        }

        // Load Youtube IFrame Player API code asynchronously
        var tag = document.createElement('script');
        tag.src = "//www.youtube.com/iframe_api";

        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
</script>
{% endcompress %}
